const ChildProcess = require(***REMOVED***child_process***REMOVED***);
const { Duplex } = require(***REMOVED***stream***REMOVED***);

let FFMPEG = {
  command: null,
  output: null,
};

const VERSION_REGEX = /version (.+) Copyright/mi;

Object.defineProperty(FFMPEG, ***REMOVED***version***REMOVED***, {
  get() {
    return VERSION_REGEX.exec(FFMPEG.output)[1];
  },
  enumerable: true,
});

/**
 * An FFmpeg transform stream that provides an interface to FFmpeg.
 * @memberof core
 */
class FFmpeg extends Duplex {
  /**
   * Creates a new FFmpeg transform stream
   * @memberof core
   * @param {Object} options Options you would pass to a regular Transform stream, plus an `args` option
   * @param {Array<string>} options.args Arguments to pass to FFmpeg
   * @example
   * // By default, if you don***REMOVED***t specify an input (`-i ...`) prism will assume you***REMOVED***re piping a stream into it.
   * const transcoder = new prism.FFmpeg({
   *  args: [
   *    ***REMOVED***-analyzeduration***REMOVED***, ***REMOVED***0***REMOVED***,
   *    ***REMOVED***-loglevel***REMOVED***, ***REMOVED***0***REMOVED***,
   *    ***REMOVED***-f***REMOVED***, ***REMOVED***s16le***REMOVED***,
   *    ***REMOVED***-ar***REMOVED***, ***REMOVED***48000***REMOVED***,
   *    ***REMOVED***-ac***REMOVED***, ***REMOVED***2***REMOVED***,
   *  ]
   * });
   * const s16le = mp3File.pipe(transcoder);
   * const opus = s16le.pipe(new prism.opus.Encoder({ rate: 48000, channels: 2, frameSize: 960 }));
   */
  constructor(options = {}) {
    super();
    this.process = FFmpeg.create(options);
    const EVENTS = {
      readable: this._reader,
      data: this._reader,
      end: this._reader,
      unpipe: this._reader,
      finish: this._writer,
      drain: this._writer,
    };

    this._readableState = this._reader._readableState;
    this._writableState = this._writer._writableState;

    this._copy([***REMOVED***write***REMOVED***, ***REMOVED***end***REMOVED***], this._writer);
    this._copy([***REMOVED***read***REMOVED***, ***REMOVED***setEncoding***REMOVED***, ***REMOVED***pipe***REMOVED***, ***REMOVED***unpipe***REMOVED***], this._reader);

    for (const method of [***REMOVED***on***REMOVED***, ***REMOVED***once***REMOVED***, ***REMOVED***removeListener***REMOVED***, ***REMOVED***removeListeners***REMOVED***, ***REMOVED***listeners***REMOVED***]) {
      this[method] = (ev, fn) => EVENTS[ev] ? EVENTS[ev][method](ev, fn) : Duplex.prototype[method].call(this, ev, fn);
    }

    const processError = error => this.emit(***REMOVED***error***REMOVED***, error);
    this._reader.on(***REMOVED***error***REMOVED***, processError);
    this._writer.on(***REMOVED***error***REMOVED***, processError);
  }

  get _reader() { return this.process.stdout; }
  get _writer() { return this.process.stdin; }

  _copy(methods, target) {
    for (const method of methods) {
      this[method] = target[method].bind(target);
    }
  }

  _destroy(err, cb) {
    super._destroy(err, cb);
    this.once(***REMOVED***error***REMOVED***, () => {});
    this.process.kill(***REMOVED***SIGKILL***REMOVED***);
  }


  /**
   * The available FFmpeg information
   * @typedef {Object} FFmpegInfo
   * @memberof core
   * @property {string} command The command used to launch FFmpeg
   * @property {string} output The output from running `ffmpeg -h`
   * @property {string} version The version of FFmpeg being used, determined from `output`.
   */

  /**
   * Finds a suitable FFmpeg command and obtains the debug information from it.
   * @param {boolean} [force=false] If true, will ignore any cached results and search for the command again
   * @returns {FFmpegInfo}
   * @throws Will throw an error if FFmpeg cannot be found.
   * @example
   * const ffmpeg = prism.FFmpeg.getInfo();
   *
   * console.log(`Using FFmpeg version ${ffmpeg.version}`);
   *
   * if (ffmpeg.output.includes(***REMOVED***--enable-libopus***REMOVED***)) {
   *   console.log(***REMOVED***libopus is available!***REMOVED***);
   * } else {
   *   console.log(***REMOVED***libopus is unavailable!***REMOVED***);
   * }
   */
  static getInfo(force = false) {
    if (FFMPEG.command && !force) return FFMPEG;
    const sources = [() => {
      const ffmpegStatic = require(***REMOVED***ffmpeg-static***REMOVED***);
      return ffmpegStatic.path || ffmpegStatic;
    }, ***REMOVED***ffmpeg***REMOVED***, ***REMOVED***avconv***REMOVED***, ***REMOVED***./ffmpeg***REMOVED***, ***REMOVED***./avconv***REMOVED***];
    for (let source of sources) {
      try {
        if (typeof source === ***REMOVED***function***REMOVED***) source = source();
        const result = ChildProcess.spawnSync(source, [***REMOVED***-h***REMOVED***], { windowsHide: true });
        if (result.error) throw result.error;
        Object.assign(FFMPEG, {
          command: source,
          output: Buffer.concat(result.output.filter(Boolean)).toString(),
        });
        return FFMPEG;
      } catch (error) {
        // Do nothing
      }
    }
    throw new Error(***REMOVED***FFmpeg/avconv not found!***REMOVED***);
  }

  /**
   * Creates a new FFmpeg instance. If you do not include `-i ...` it will be assumed that `-i -` should be prepended
   * to the options and that you***REMOVED***ll be piping data into the process.
   * @param {String[]} [args=[]] Arguments to pass to FFmpeg
   * @returns {ChildProcess}
   * @private
   * @throws Will throw an error if FFmpeg cannot be found.
   */
  static create({ args = [] } = {}) {
    if (!args.includes(***REMOVED***-i***REMOVED***)) args.unshift(***REMOVED***-i***REMOVED***, ***REMOVED***-***REMOVED***);
    return ChildProcess.spawn(FFmpeg.getInfo().command, args.concat([***REMOVED***pipe:1***REMOVED***]), { windowsHide: true });
  }
}

module.exports = FFmpeg;
