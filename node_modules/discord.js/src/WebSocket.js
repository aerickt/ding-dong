***REMOVED***use strict***REMOVED***;

const { browser } = require(***REMOVED***./util/Constants***REMOVED***);

let erlpack;

try {
  erlpack = require(***REMOVED***erlpack***REMOVED***);
  if (!erlpack.pack) erlpack = null;
} catch {} // eslint-disable-line no-empty

let TextDecoder;

if (browser) {
  TextDecoder = window.TextDecoder; // eslint-disable-line no-undef
  exports.WebSocket = window.WebSocket; // eslint-disable-line no-undef
} else {
  TextDecoder = require(***REMOVED***util***REMOVED***).TextDecoder;
  exports.WebSocket = require(***REMOVED***ws***REMOVED***);
}

const ab = new TextDecoder();

exports.encoding = erlpack ? ***REMOVED***etf***REMOVED*** : ***REMOVED***json***REMOVED***;

exports.pack = erlpack ? erlpack.pack : JSON.stringify;

exports.unpack = (data, type) => {
  if (exports.encoding === ***REMOVED***json***REMOVED*** || type === ***REMOVED***json***REMOVED***) {
    if (typeof data !== ***REMOVED***string***REMOVED***) {
      data = ab.decode(data);
    }
    return JSON.parse(data);
  }
  if (!Buffer.isBuffer(data)) data = Buffer.from(new Uint8Array(data));
  return erlpack.unpack(data);
};

exports.create = (gateway, query = {}, ...args) => {
  const [g, q] = gateway.split(***REMOVED***?***REMOVED***);
  query.encoding = exports.encoding;
  query = new URLSearchParams(query);
  if (q) new URLSearchParams(q).forEach((v, k) => query.set(k, v));
  const ws = new exports.WebSocket(`${g}?${query}`, ...args);
  if (browser) ws.binaryType = ***REMOVED***arraybuffer***REMOVED***;
  return ws;
};

for (const state of [***REMOVED***CONNECTING***REMOVED***, ***REMOVED***OPEN***REMOVED***, ***REMOVED***CLOSING***REMOVED***, ***REMOVED***CLOSED***REMOVED***]) exports[state] = exports.WebSocket[state];
